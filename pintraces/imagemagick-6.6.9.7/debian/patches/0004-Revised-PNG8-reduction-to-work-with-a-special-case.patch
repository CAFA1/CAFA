From 991f4ebaeaba35386d3cdc860f434c66c77bef9f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Bastien=20ROUCARI=C3=88S?= <roucaries.bastien@gmail.com>
Date: Wed, 15 Jun 2011 23:41:00 +0200
Subject: [PATCH] Revised PNG8 reduction to work with a special case

This patch fix png that reduces to 256 opaque colors plus transparency.

A build of the package in testing is fine, a build of the package in unstable
is broken.  tango-icon-theme's install process does a "convert input.png
/target/output.png".

This is a know bug of imagemagick fixed in 6.6.9.8

cherry picked from commit a5a4705b639217c893861d802c3cf4c0a749943

Author: Glenn Randers-Pehrson <glennrp@imagemagick.org>
Bug-Debian: http://bugs.debian.org/609177
Last-Update: 2011-06-15
Applied-Upstream: 6.6.9.8

git-svn-id: https://www.imagemagick.org/subversion/ImageMagick/trunk@4429 aa41f4f7-0bf4-0310-aa73-e5a19afd5a74
---
 coders/png.c |   99 ++++++++++++++++++++++++++++++++++++++++++++-------------
 1 files changed, 76 insertions(+), 23 deletions(-)

diff --git a/coders/png.c b/coders/png.c
index 6ff2916..6afd815 100644
--- a/coders/png.c
+++ b/coders/png.c
@@ -7013,6 +7013,7 @@ static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,
     ping_need_colortype_warning,
 
     status,
+    tried_332,
     tried_333,
     tried_444;
 
@@ -7202,15 +7203,17 @@ static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,
   /* Normally we run this just once, but in the case of writing PNG8
    * we reduce the transparency to binary and run again, then if there
    * are still too many colors we reduce to a simple 4-4-4-1, then 3-3-3-1
-   * RGBA palette and run again, and finally to a simple 3-3-2-1 RGBA
-   * palette.  The final reduction can only fail if there are still 256
-   * colors present and one of them has both transparent and opaque instances.
+   * RGBA palette and run again, and then to a simple 3-3-2-1 RGBA
+   * palette.  Then (To do) we take care of a final reduction that is only
+   * needed if there are still 256 colors present and one of them has both
+   * transparent and opaque instances.
    */
 
+  tried_332 = MagickFalse;
   tried_333 = MagickFalse;
   tried_444 = MagickFalse;
 
-  for (j=0; j<5; j++)
+  for (j=0; j<6; j++)
   {
     /* BUILD_PALETTE
      *
@@ -7759,9 +7762,13 @@ static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,
 
           for (x=0; x < (ssize_t) image->columns; x++)
           {
-              SetOpacityPixelComponent(r,
-              ((GetOpacityPixelComponent(r) > TransparentOpacity/2) ?
-                   TransparentOpacity : OpaqueOpacity));
+              if (GetOpacityPixelComponent(r) > TransparentOpacity/2)
+                {
+                  SetOpacityPixelComponent(r,TransparentOpacity);
+                  SetRGBPixelComponents(r,image->background_color);
+                }
+              else
+                  SetOpacityPixelComponent(r,OpaqueOpacity);
               r++;
           }
   
@@ -7814,11 +7821,7 @@ static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,
 
             for (x=0; x < (ssize_t) image->columns; x++)
             {
-              if (GetOpacityPixelComponent(r) == TransparentOpacity)
-                {
-                  SetRGBPixelComponents(r,image->background_color);
-                }
-              else
+              if (GetOpacityPixelComponent(r) == OpaqueOpacity)
                 {
                   hi4=ScaleQuantumToChar(GetRedPixelComponent(r)) & 0xf0;
                   SetRedPixelComponent(r,ScaleCharToQuantum((hi4 | (hi4 >>
@@ -7895,11 +7898,7 @@ static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,
 
             for (x=0; x < (ssize_t) image->columns; x++)
             {
-              if (GetOpacityPixelComponent(r) == TransparentOpacity)
-                {
-                  SetRGBPixelComponents(r,image->background_color);
-                }
-              else
+              if (GetOpacityPixelComponent(r) == OpaqueOpacity)
                 {
                   hi3=ScaleQuantumToChar(GetRedPixelComponent(r)) & 0xe0;
                   hi2=hi3 & 0xc0;
@@ -7947,12 +7946,14 @@ static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,
         continue;
       }
 
-    if (image_colors == 0 || image_colors > 256)
+    if (tried_332 == MagickFalse && (image_colors == 0 || image_colors > 256))
       {
         if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                "    Quantizing the background color to 3-3-2");
 
+        tried_332 = MagickTrue;
+
         /* Red and green were already done so we only quantize the blue
          * channel
          */
@@ -7977,11 +7978,7 @@ static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,
 
             for (x=0; x < (ssize_t) image->columns; x++)
             {
-              if (GetOpacityPixelComponent(r) == TransparentOpacity)
-                {
-                  SetRGBPixelComponents(r,image->background_color);
-                }
-              else
+              if (GetOpacityPixelComponent(r) == OpaqueOpacity)
                 {
                   hi2=ScaleQuantumToChar(GetBluePixelComponent(r)) & 0xc0;
                   SetBluePixelComponent(r,ScaleCharToQuantum(
@@ -8011,6 +8008,62 @@ static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,
       continue;
     }
     break;
+
+    if (image_colors == 0 || image_colors > 256)
+    {
+      /* Take care of special case with 256 colors + 1 transparent
+       * color.  We don't need to quantize to 2-3-2-1; we only need to
+       * eliminate one color, so we'll merge the two darkest red
+       * colors (0x49, 0, 0) -> (0x24, 0, 0).
+       */
+      if (ScaleQuantumToChar(image->background_color.red) == 0x49 &&
+          ScaleQuantumToChar(image->background_color.green) == 0x00 &&
+          ScaleQuantumToChar(image->background_color.blue) == 0x00)
+      {
+         image->background_color.red=ScaleCharToQuantum(0x24);
+      }
+  
+      if (image->colormap == NULL)
+      {
+        for (y=0; y < (ssize_t) image->rows; y++)
+        {
+          r=GetAuthenticPixels(image,0,y,image->columns,1,
+              exception);
+  
+          if (r == (PixelPacket *) NULL)
+            break;
+  
+          for (x=0; x < (ssize_t) image->columns; x++)
+          {
+            if (ScaleQuantumToChar(GetRedPixelComponent(r)) == 0x49 &&
+                ScaleQuantumToChar(GetGreenPixelComponent(r)) == 0x00 &&
+                ScaleQuantumToChar(GetBluePixelComponent(r)) == 0x00 &&
+                GetOpacityPixelComponent(r) == OpaqueOpacity)
+              {
+                SetRedPixelComponent(r,ScaleCharToQuantum(0x24));
+              }
+            r++;
+          }
+      
+          if (SyncAuthenticPixels(image,exception) == MagickFalse)
+             break;
+  
+        }
+      }
+
+      else
+      {
+         for (i=0; i<image_colors; i++)
+         {
+            if (ScaleQuantumToChar(image->colormap[i].red) == 0x49 &&
+                ScaleQuantumToChar(image->colormap[i].green) == 0x00 &&
+                ScaleQuantumToChar(image->colormap[i].blue) == 0x00)
+            {
+               image->colormap[i].red=ScaleCharToQuantum(0x24);
+            }
+         }
+      }
+    }
   }
   /* END OF BUILD_PALETTE */
 
-- 
1.7.5.3

